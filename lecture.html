<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <style>
/*--------------------------------------------------------------------------------------------- * Copyright (c) Microsoft Corporation. All rights reserved. * Licensed under the MIT License. See License.txt in the project root for license information. *--------------------------------------------------------------------------------------------*/ body { font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback"; font-size: 14px; padding: 0 12px; line-height: 22px; word-wrap: break-word; } body.scrollBeyondLastLine { margin-bottom: calc(100vh - 22px); } body.showEditorSelection .code-line { position: relative; } body.showEditorSelection .code-active-line:before, body.showEditorSelection .code-line:hover:before { content: ""; display: block; position: absolute; top: 0; left: -12px; height: 100%; } body.showEditorSelection li.code-active-line:before, body.showEditorSelection li.code-line:hover:before { left: -30px; } .vscode-light.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(0, 0, 0, 0.15); } .vscode-light.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(0, 0, 0, 0.40); } .vscode-dark.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 255, 255, 0.4); } .vscode-dark.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 255, 255, 0.60); } .vscode-high-contrast.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 160, 0, 0.7); } .vscode-high-contrast.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 160, 0, 1); } img { max-width: 100%; max-height: 100%; } a { color: #4080D0; text-decoration: none; } a:focus, input:focus, select:focus, textarea:focus { outline: 1px solid -webkit-focus-ring-color; outline-offset: -1px; } hr { border: 0; height: 2px; border-bottom: 2px solid; } h1 { padding-bottom: 0.3em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; } h1, h2, h3 { font-weight: normal; } h1 code, h2 code, h3 code, h4 code, h5 code, h6 code { font-size: inherit; line-height: auto; } a:hover { color: #4080D0; text-decoration: underline; } table { border-collapse: collapse; } table > thead > tr > th { text-align: left; border-bottom: 1px solid; } table > thead > tr > th, table > thead > tr > td, table > tbody > tr > th, table > tbody > tr > td { padding: 5px 10px; } table > tbody > tr + tr > td { border-top: 1px solid; } blockquote { margin: 0 7px 0 5px; padding: 0 16px 0 10px; border-left: 5px solid; } code { font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback"; font-size: 14px; line-height: 19px; } body.wordWrap pre { white-space: pre-wrap; } .mac code { font-size: 12px; line-height: 18px; } code > div { padding: 16px; border-radius: 3px; overflow: auto; } /** Theming */ .vscode-light { color: rgb(30, 30, 30); } .vscode-dark { color: #DDD; } .vscode-high-contrast { color: white; } .vscode-light code { color: #A31515; } .vscode-dark code { color: #D7BA7D; } .vscode-light code > div { background-color: rgba(220, 220, 220, 0.4); } .vscode-dark code > div { background-color: rgba(10, 10, 10, 0.4); } .vscode-high-contrast code > div { background-color: rgb(0, 0, 0); } .vscode-high-contrast h1 { border-color: rgb(0, 0, 0); } .vscode-light table > thead > tr > th { border-color: rgba(0, 0, 0, 0.69); } .vscode-dark table > thead > tr > th { border-color: rgba(255, 255, 255, 0.69); } .vscode-light h1, .vscode-light hr, .vscode-light table > tbody > tr + tr > td { border-color: rgba(0, 0, 0, 0.18); } .vscode-dark h1, .vscode-dark hr, .vscode-dark table > tbody > tr + tr > td { border-color: rgba(255, 255, 255, 0.18); } .vscode-light blockquote, .vscode-dark blockquote { background: rgba(127, 127, 127, 0.1); border-color: rgba(0, 122, 204, 0.5); } .vscode-high-contrast blockquote { background: transparent; border-color: #fff; }
</style>
<style>
/* Tomorrow Theme */ /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */ /* Original theme - https://github.com/chriskempson/tomorrow-theme */ /* Tomorrow Comment */ .hljs-comment, .hljs-quote { color: #8e908c; } /* Tomorrow Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-deletion { color: #c82829; } /* Tomorrow Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-meta, .hljs-link { color: #f5871f; } /* Tomorrow Yellow */ .hljs-attribute { color: #eab700; } /* Tomorrow Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #718c00; } /* Tomorrow Blue */ .hljs-title, .hljs-section { color: #4271ae; } /* Tomorrow Purple */ .hljs-keyword, .hljs-selector-tag { color: #8959a8; } .hljs { display: block; overflow-x: auto; color: #4d4d4c; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }
</style>
<style>
ul.contains-task-list { padding-left: 0; } ul ul.contains-task-list { padding-left: 40px; } .task-list-item { list-style-type: none; } .task-list-item-checkbox { vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
    </head>
    <body>
        <h1 id="">问题重述</h1>
<h2 id="">问题背景</h2>
<p>现有一个二维的CT系统，平行射入X射线，每个探测器单元看作一个接收点，接收点等距排列。X射线的发射器和探测器相对位置固定不变。在该CT系统的实际应用过程中，整个发射-接受系统绕一个<strong>固定的旋转中心</strong>旋转180次。每一个X射线方向上，等距的512个探测单元都能接收到一组衰减后射线能量的值，经过增益处理后得到180组数据，即得到一个180*512的数组。</p>
<p>因为安装时系统误差的存在（旋转中心，旋转角度的偏差），在实际应用的时候需要对该CT系统进行<strong>标定</strong>。利用已知结构的样品（模板）标定CT的参数，并据此对未知结构的样品进行成像。</p>
<p>标定类的题目也出现在2008年国赛A题中。这种题目同时含有正运算（标定）、逆运算（根据标定参数还原图像）两种模型，求解过程对精度有较高的要求，是一类比较经典的A题。</p>
<p>通过读题，我们可以带着以下几点疑惑去做题：</p>
<ol>
<li>每个探测器的到的值是“<strong>经过增益等处理后</strong>”的值。这句话实际上降低了题目的难度，我们可以猜测这个<strong>增益</strong>过程是将原来的某种非线性/负相关的关系转化为一种线性正相关的关系。具体讨论请见下文。</li>
<li>512个探测单元的长度应该大于标定模板的最大投影长度（根号2倍正方形边长）</li>
<li>旋转180次，感性上讲应该是每次旋转1度左右。这样才能覆盖整个物体的全方位信息。</li>
</ol>
<h2 id="">需要解决的问题</h2>
<ol>
<li><strong>标定参数</strong>。在问题背景中已经详细阐述</li>
<li><strong>重构图像</strong>。可以发现第二问第三问其实是同一个问题。区别可能在于第三问中数据更加复杂。具体复杂到什么情况，我们在具体问题中详细分析。</li>
<li><strong>精度与稳定性分析</strong>。经典的A题第四问。</li>
<li><strong>设计模板</strong>。开放式问题。为什么要设计模板？第一问中的模板有哪些不好？</li>
</ol>
<p>带着问题去做题。</p>
<h1 id="">问题一的求解</h1>
<h2 id="">求解思路</h2>
<ol>
<li>通过部分数据获得模型的初步信息。</li>
<li>建立完整模型</li>
<li>迭代求解拟合模型</li>
</ol>
<h2 id="">初值计算</h2>
<p>刚才提到了，数据是经过<strong>增益处理</strong>后得到的，具体增益值是多少，我们先通过预处理获得其大值值，这样心里有底。除增益值$\mu$之外，还有什么参数呢？</p>
<p>请看图，我们能想到的参数还有：探测器间的距离$\delat d$，模板旋转中心在探测器上的投影，与探测器中心（第256个单元与第257个单元的中点）的距离$d$。</p>
<p>通过初步的观察，我们先做一个大胆的猜测：探测器上的吸收值与模板上有吸收率的弦长成一次线性关系$\mu \times l + c$。取某一角度下的数据，以$\mu, \delta d, d_0, c$为参数进行最小二乘拟合，发现拟合优度异常的高。我们的大胆假设是正确的。</p>
<h2 id="">完整模型的建立</h2>
<p>需要求解的参数：</p>
<ol>
<li>旋转中心$(x_0, y_0)$</li>
<li>180个旋转角（规定为探测器平面与x轴的夹角）</li>
<li>前文所说的$\mu$, $d_0$, $\delta d$</li>
</ol>
<p>一共185个变量。一般来说，直接根据180*512个数据，直接求解看上去很困难，但是我们设计了<strong>迭代优化算法</strong>对该规划进行求解。</p>
<h2 id="">迭代优化算法</h2>
<ol>
<li>选取185个参数的初值（几乎可以任意取值）。带入fitnlm中计算，得到第一次求解的参数结果。这时，圆心坐标可能稍有偏差，但角度值几乎稳定在60-240度。</li>
<li>将第一次迭代的结果进行数据平滑处理，使用局部加权回归散点平滑法。LOWESS 主要思想是取一定比例的局部数据，在这部分子集中拟合多项式回归曲线。这时为了使得到的角度较为平滑，更符合实际情况。</li>
<li>重复上述步骤，将上次得到的结果作为初值，带入下一次求解中。多重复几次操作后，发现结果稳定。此值即为结果。</li>
</ol>
<h2 id="">求解结果</h2>
<h1 id="">问题二的求解</h1>
<h2 id="">求解思路</h2>
<p>第二问的问题是，给定一组180*512 的数据，反求原图像。这里不得不提到一篇参考文献，庄天戈. CT原理与算法。这本书从二维讲起，详细描述了CT的基本数学知识与具体的算法实现。在CT中，Radon定理起到了一个很重要的作用。他证明了线积分与投影的积分有对应关系。</p>
<p>有了基础的数学知识，我们将建立具体的数学模型和算法。在本节中，我们讨论连续模型和离散模型。</p>
<h2 id="">数据预处理</h2>
<p>为了使算法有更强的鲁棒性与可移植性，我们有一个数据预处理阶段。因为安装的误差，CT系统的旋转中心不在正方形的中心。由前文推导公式可知，探测器上的第i个传感器与坐标原点的沿探测器方向的距离为下式。</p>
<p>现在虚拟一个探测器，其旋转中心在原点，$\delta d$ 相等，$d'$根据下面的公式计算。</p>
<p>那么虚拟探测器上的投影值可以表示成下式：</p>
<p>$data_{pre}(i',j) = data(i(i'),j)$
$= data(i' - (x_0\cos\phi + y_0\sin\phi + d_0)/\Delta d,j)$</p>
<p>可以从下图发现，利用旋转数据的一一对应，我们把原来稍有歪扭的数据拉正了。</p>
<p>这样的预处理有诸多好处，即先根据标定结果，通过预处理把数据转换为标准型数据，再调用标准的反投影算法进行求解，使算法更有通用性。</p>
<h2 id="">连续模型</h2>
<p>对于反投影标定，我们先提出一个基于傅里叶变换的连续模型。f(x, y)为CT扫描的物体的吸收率函数，$P_\theta$为关于某条射线的线积分，也就是我们得到的投影值，把$P_\theta$进行傅里叶变换，得到$S_\theta$。傅里叶中心切片定理将二维图像的傅里叶变换和投影的傅里叶变换建立了联系，现在可以根据充足数目方向上的投影的傅里叶变换信息，构造出原始函数的估计值。</p>
<p>$$P_\theta (t) = \int_{(\theta, t) line}f(x, y)\ ds$$</p>
<p>$$S_\theta (w) = \int_{-\infty}^{\infty}P_\theta (t) e^{-j2\pi wt}dt $$</p>
<p>$$F(u, v) = \int_{-\infty}^{\infty}\int_{-\infty}^{\infty} f(x, y)e^{-j2\pi (ux + vy)}dt$$</p>
<p>$$S_\theta (w) = F(w\cos\theta, w\sin\theta)$$</p>
<h3 id="">滤波，拟合？？？</h3>
<h2 id="">离散模型</h2>
<p>具体的算法采用FBP，滤波反投影算法。</p>
<ol>
<li>指定投影的角度，对线积分进行傅里叶变换，对我们本题来说直接用离散的FFT。</li>
<li>对线积分的FFT滤波。涉及到频域的计算都需要进行一定程度的滤波，在本题中，如果不滤的话，一些原本吸收率等于0的点对应的反变换会有一定大小的值（星状伪迹）。但根据Paley-Wiener theorem，理想的斜坡滤波器不可实现。参考文献后发现工程上常用的滤波器为三角形窗口滤波器。</li>
<li>iFFT</li>
<li>重建</li>
</ol>
<h2 id="art">离散模型ART</h2>
<p>设图片有J = n*n个像素，设一个J维的图像矢量，即把n *n个像素排列一下。x_j 表示图像上第j个像素点的吸收强度。设有I条射线（512），p表示第i条射线所经过的所有像素的投影值。构造矩阵R i-by-j，矩阵中的元素为0-1变量，表示宽度为$\delta$的粗射线i是否穿过像素j。若穿过，则赋给R(i, j) = 1</p>
<p>我们可以得到Rx = p。</p>
<p>左侧成为伪射线和，右侧使真射线和。要将图像的吸收强度求解出来，需要对R求逆。但我们也可以看到R使大型稀疏矩阵，直接求逆很困难，而且误差的存在可能使R奇异。通常使用迭代法进行求解。</p>
<p>ART的思路是每次校正一条射线路径上的像素值，使该真伪射线的误差最小。迭代公式如下。</p>
<p>中间有一个松弛参数，取0.25，可以证明此取值可以使算法收敛。</p>
<h2 id="">降噪算法</h2>
<p>求完之后需要有一个降噪处理。我们采用了NLM算法，非局部均值对图像进行处理。对每一个像素点进行操作，对像素的某邻域窗口的像素灰度进行加权平均，像素越相似，权重越大。</p>
<h2 id="">结果</h2>
<p>如图所示。可以看到FBP的成像更为清晰。</p>
<p>指定十个点的重建值。对精度的要求很高的。旋转中心/旋转角度稍有偏差就会导致结果千差万别。</p>
<h1 id="">问题三的求解</h1>
<p>问题三和问题二的要求完全一致，我们需要找出其中的不同之处——噪声变多。</p>
<p>实际上第三问就是再次检验算法的鲁棒性的。</p>
<h2 id="">求解思路</h2>
<p>先观察数据。作出数据差分图，发现数据主要集中在探测器中部。再观察这些边缘数据，发现其无规律波动，猜测其服从均匀分布。利用KS检验，检验均匀分布，显著水平0.157。故我们可以先进行预处理：在边缘部分直接把吸收值置零，在中间数据部分减去0.15。</p>
<h2 id="">求解结果</h2>
<h2 id="">对比与评价</h2>
<p>对比两种算法，ART-NLM 算法的重建速度较慢，成像质量略差与FBP。我们认为这是由于投影矩阵R 元素为0-1 变量造成的；每次做迭代修正时，射线边的像素也同时受到等值的修正，造成了一定的偏差</p>
<h1 id="">问题四的求解</h1>
<h2 id="">精度分析</h2>
<p>这里是例行的模型评价环节了。对于精度，我们采用另给数据进行仿真的犯法来检验算法的精度。</p>
<p>结果见表格，误差值甚至可以达到及其精度。</p>
<h2 id="">稳定性分析</h2>
<p>加噪声，进行仿真。一样地加均匀分布噪声。</p>
<p>0.0053rad就是0.3度。在可接受地范围内。其他参数精度较高。</p>
<h2 id="">新模板的设计</h2>
<p>为何设计新模板？
如果可以设计一种模板，利用几何关系可以直接求出一些参数地初值，再进行迭代，可以大大减小计算量。</p>
<p>模板要求：能写出简洁的解析表达式。</p>
<p>新标定模板如图所示。一大一小两个圆，轴对称但不中心对称。</p>
<p>初值的寻找：x_0, y_0, d_0。均由途中几何关系很容易得出。</p>
<p>只进行一次迭代：结果分析，误差小于0.5%</p>
<h1 id="">改进与讨论</h1>
<h2 id="art">ART的改进</h2>
<p>原来求解R的方法：先构造256*256 的矩阵r，令其中一列等于1，旋转r，得到投影值。</p>
<p>新方法：写出直线方程，求出指定行与列与直线相交最左最右的像素，按顺序计算范围内每个像素的值。遍历所有行。</p>
<p>重建结果：几乎和答案一致</p>
<h2 id="fbp">FBP</h2>
<p>FBP中反投影矩阵的维度一定为探测单元数，即512。实际图像中存在将结果resize为256*256的过程，在其中需要乘以一个系数；同时在缩放过程中，像素的值也需要做调整。</p>
<p>另一方面，因为在连续模型中使用FFT会导致舍入误差的出现，加上FBP中有一个低通滤波，会使数据有一定失真，导致FBP的结果比实际结果要小。</p>
<h1 id="">心得体会</h1>
<h2 id="">赛前准备</h2>
<p>我们小组早在五月六月就开始了国赛的准备。当时基本讨论好我们曾经参加数学建模竞赛的得与失，拟好了作战计划：专注求解方法，专注于论文的写作。</p>
<p>八月九月：准备时间。把所有能用的优化算法都自己实现了一遍。数值计算我们也都修读过，对此也不陌生。模型方面我们看了Optimization Model with LINGO这本书，它是讲lingo的但里面有很多建模方法。还有就是研究了往届国赛题，确定了我们更倾向于做A题。</p>
<h2 id="">比赛时间轴</h2>
<ul>
<li>9月14日20：00发题，24：00前确定题目，把整个题目框架搭好。</li>
<li>9月15日中午之前，第一问模型建立，开始求解。</li>
<li>9月15日20：00前把第一问结束。开始着手第二三问，建立二三问模型。</li>
<li>9月16日中午之前，第二问第三问模型基本建成，开始求解。同时着手稳定性分析。抽空思考自己设计的模板。</li>
<li>9月16日下午开始写论文，把能写的先写掉。</li>
<li>9月16日24：00前把第二问和第三问解决。</li>
<li>9月17日写论文，完善模型及求解，完成第四问。</li>
</ul>
<p>留出充足时间推敲论文！</p>
<h2 id="matlab">MATLAB</h2>
<ol>
<li>关键在于不用几何信息求解第一问也能求得很准确的结果。</li>
<li>准确比较了第二问第三问的区别，发现了第三问噪声的均匀分布</li>
<li>论文框架完整，第一问到第四问样样全面。</li>
<li>没有使用iradon函数。</li>
</ol>

    </body>
    </html>